# HumanRuntime

Ever since the concept of time emerged, people have started to divide it into three stages: "past," "present," and "future."
We summarize the "past" as experience to feed the "present," predicting the "future." Previously, the method of summary was books, but now there is a new way, which we call AI.

The history of programming languages has an obvious development path, from which we can extract a main line.
From machine language to assembly, then to low-level languages, or more specifically: C. Following this was the expansion of C into C++, reaching a stage where the complexity of the language was such that the characteristics of the machine were highly abstracted. Abstraction is a subjective process with a target, and chaotic abstraction does not yield an orderly structure. The abstraction of programming languages, however, leans towards human habits, thus naturally giving birth to high-level languages such as Java/C#. When abstraction reached its limits, the importance of usability began to rise, leading to the widespread adoption of Python/js. So, what's the next step?

In fact, it's a future that everyone can think of: the direct translation of human language into machine language. There are two major challenges in this: understanding machine language and understanding human language, and then unifying the two. The former has been achieved in the past with human intelligence and logic, erecting a logical and abstract edifice for machines. The latter, however, has found a new light.

In reality, we have always had the ability to translate human language into machine language. By manually interpreting enough human statements, we can operate machines in everyday language to a certain extent, which is also one of the development directions of the current Internet of Things, but there is still too little work done. We are always looking for an elegant and generalizable solution, which ironically hinders the progress of work that could be achieved by accumulation.

However, the accumulation of chips and AI has been effective, giving us another opportunity to seek new elegance.

In operating machines, or rather in programming languages, pioneers finally tried to make AI write code directly, but so far, its effectiveness is still questionable. Therefore, they turned to a more modest approach: assisting in code generation, trying to understand the developer's intent, and completing the code. This is the idea behind GitHub Copilot and similar tools.

But the necessity of Copilot's existence is indeed questionable. We can say that Copilot's existence is to verify the feasibility of "understanding humans" to "completing programming," or it could be for augmenting AI's own dataset. But it could also be said that it's just allowing human programmers to linger a bit longer, to shine a bit more before AI can directly and perfectly generate code.

I will never deny programmers who are very thoughtful and in-depth and what they can do in any era, but for most developers, we are just struggling. Maybe this respite will continue for a long time due to political, economic and other factors , but when the glory of the times dims, some things are self-evident.

So what can we do?

I have always hoped to build a library of ideas, collecting the thoughts of thinkers. Perhaps these ideas could one day become the foundation of the world, or even if not, they are still the most beautiful crystallization of humanity. I hope this repository can gather many people's thoughts on various fields, then become like a library.

And today, my thought is to find a direct way to contribute to the future. When AI can truly and effectively generate code, what tools will it need to adapt to the next generation's environment and create the next generation's products!
